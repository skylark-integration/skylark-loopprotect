{"version":3,"sources":["skylark-loopprotect.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-loopprotect.js","sourcesContent":["define('skylark-loopprotect/main',[],function(){\r\n  /*global DEBUG*/\r\n  'use strict';\r\n  var debug = null;\r\n\r\n  // the standard loops - note that recursive is not supported\r\n  var re = /\\b(for|while|do)\\b/g;\r\n  var reSingle = /\\b(for|while|do)\\b/;\r\n  var labelRe = /\\b(?!default:)([a-z_]{1}\\w+:)/i;\r\n  var comments = /(?:\\/\\*(?:[\\s\\S]*?)\\*\\/)|(?:([\\s;])+\\/\\/(?:.*)$)/gm;\r\n\r\n  var loopProtect = rewriteLoops;\r\n\r\n  // used in the loop detection\r\n  loopProtect.counters = {};\r\n\r\n  // expose debug info\r\n  loopProtect.debug = function debugSwitch(state) {\r\n    debug = state ? function () {\r\n      console.log.apply(console, [].slice.apply(arguments));\r\n    } : function () {};\r\n  };\r\n\r\n  loopProtect.debug(false); // off by default\r\n\r\n  // the method - as this could be aliased to something else\r\n  loopProtect.alias = 'loopProtect';\r\n\r\n  function inMultilineComment(lineNum, lines) {\r\n    if (lineNum === 0) {\r\n      return false;\r\n    }\r\n\r\n    var j = lineNum;\r\n    var closeCommentTags = 1; // let's assume we're inside a comment\r\n    var closePos = -1;\r\n    var openPos = -1;\r\n\r\n    do {\r\n      debug('looking backwards ' + lines[j]); // jshint ignore:line\r\n      closePos = lines[j].indexOf('*/');\r\n      openPos = lines[j].indexOf('/*');\r\n\r\n      if (closePos !== -1) {\r\n        closeCommentTags++;\r\n      }\r\n\r\n      //check for single line /* comment */ formatted comments.\r\n      if (closePos === lines[j].length - 2 && openPos !== -1) {\r\n        closeCommentTags--;\r\n      }\r\n\r\n      if (openPos !== -1) {\r\n        closeCommentTags--;\r\n\r\n        if (closeCommentTags === 0) {\r\n          debug('- exit: part of a multiline comment'); // jshint ignore:line\r\n          return true;\r\n        }\r\n      }\r\n      j -= 1;\r\n    } while (j !== 0);\r\n\r\n    return false;\r\n  }\r\n\r\n  function inCommentOrString(index, line) {\r\n    var character;\r\n    while (--index > -1) {\r\n      character = line.substr(index, 1);\r\n      if (character === '\"' || character === '\\'' || character === '.') {\r\n        // our loop keyword was actually either in a string or a property, so let's exit and ignore this line\r\n        debug('- exit: matched inside a string or property key'); // jshint ignore:line\r\n        return true;\r\n      }\r\n      if (character === '/' || character === '*') {\r\n        // looks like a comment, go back one to confirm or not\r\n        --index;\r\n        if (character === '/') {\r\n          // we've found a comment, so let's exit and ignore this line\r\n          debug('- exit: part of a comment'); // jshint ignore:line\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function directlyBeforeLoop(index, lineNum, lines) {\r\n    reSingle.lastIndex = 0;\r\n    labelRe.lastIndex = 0;\r\n    var beforeLoop = false;\r\n\r\n    var theRest = lines.slice(lineNum).join('\\n').substr(index).replace(labelRe, '');\r\n    theRest.replace(reSingle, function commentStripper(match, capture, i) {\r\n      var target = theRest.substr(0, i).replace(comments, '').trim();\r\n      debug('- directlyBeforeLoop: ' + target); // jshint ignore:line\r\n      if (target.length === 0) {\r\n        beforeLoop = true;\r\n      }\r\n      // strip comments out of the target, and if there's nothing else\r\n      // it's a valid label...I hope!\r\n    });\r\n\r\n    return beforeLoop;\r\n  }\r\n\r\n  /**\r\n   * Look for for, while and do loops, and inserts *just* at the start of the\r\n   * loop, a check function.\r\n   */\r\n  function rewriteLoops(code, offset) {\r\n    var recompiled = [];\r\n    var lines = code.split('\\n');\r\n    var disableLoopProtection = false;\r\n    var method = loopProtect.alias + '.protect';\r\n    var ignore = {};\r\n    var pushonly = {};\r\n    var labelPostion = null;\r\n\r\n    function insertReset(lineNum, line, matchPosition) {\r\n      // recompile the line with the reset **just** before the actual loop\r\n      // so that we insert in to the correct location (instead of possibly\r\n      // outside the logic\r\n      // wrap reset and loop in a block to avoid one line loop behind\r\n      // `if (false)`, insert the open brace in this function, and the close\r\n      // brace after loop close brace.\r\n      return line.slice(0, matchPosition) + '{;' + method + '({ line: ' + lineNum + ', reset: true }); ' + line.slice(matchPosition);\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    lines.forEach(function eachLine(line, lineNum) {\r\n      // reset our regexp each time.\r\n      re.lastIndex = 0;\r\n      labelRe.lastIndex = 0;\r\n\r\n      if (disableLoopProtection) {\r\n        return;\r\n      }\r\n\r\n      if (line.toLowerCase().indexOf('noprotect') !== -1) {\r\n        disableLoopProtection = true;\r\n      }\r\n\r\n      var index = -1;\r\n      var matchPosition = -1;\r\n      var originalLineNum = lineNum;\r\n      // +1 since we're humans and don't read lines numbers from zero\r\n      var printLineNumber = lineNum - offset + 1;\r\n      var character = '';\r\n      // special case for `do` loops, as they're end with `while`\r\n      var dofound = false;\r\n      var findwhile = false;\r\n      var terminator = false;\r\n      var matches = line.match(re) || [];\r\n      var match = matches.length ? matches[0] : '';\r\n      var labelMatch = line.match(labelRe) || [];\r\n      var openBrackets = 0;\r\n      var openBraces = 0;\r\n      var foundLoopEnd = false;\r\n\r\n      if (labelMatch.length) {\r\n        debug('- label match'); // jshint ignore:line\r\n        index = line.indexOf(labelMatch[1]);\r\n        if (!inCommentOrString(index, line)) {\r\n          if (!inMultilineComment(lineNum, lines)) {\r\n            if (directlyBeforeLoop(index, lineNum, lines)) {\r\n              debug('- found a label: \"' + labelMatch[0] + '\"'); // jshint ignore:line\r\n              labelPostion = lineNum;\r\n            } else {\r\n              debug('- ignored \"label\", false positive'); // jshint ignore:line\r\n            }\r\n          } else {\r\n            debug('- ignored label in multline comment'); // jshint ignore:line\r\n          }\r\n        } else {\r\n          debug('- ignored label in string or comment'); // jshint ignore:line\r\n        }\r\n      }\r\n\r\n      if (ignore[lineNum]) {\r\n        debug(' -exit: ignoring line ' + lineNum +': ' + line); // jshint ignore:line\r\n        return;\r\n      }\r\n\r\n      if (pushonly[lineNum]) {\r\n        debug('- exit: ignoring, but adding line ' + lineNum + ': ' + line); // jshint ignore:line\r\n        recompiled.push(line);\r\n        return;\r\n      }\r\n\r\n      // if there's more than one match, we just ignore this kind of loop\r\n      // otherwise I'm going to be writing a full JavaScript lexer...and god\r\n      // knows I've got better things to be doing.\r\n      if (match && matches.length === 1 && line.indexOf('jsbin') === -1) {\r\n        debug('match on ' + match + '\\n'); // jshint ignore:line\r\n\r\n        // there's a special case for protecting `do` loops, we need to first\r\n        // prtect the `do`, but then ignore the closing `while` statement, so\r\n        // we reset the search state for this special case.\r\n        dofound = match === 'do';\r\n\r\n        // make sure this is an actual loop command by searching backwards\r\n        // to ensure it's not a string, comment or object property\r\n        matchPosition = index = line.indexOf(match);\r\n\r\n        // first we need to walk backwards to ensure that our match isn't part\r\n        // of a string or part of a comment\r\n        if (inCommentOrString(index, line)) {\r\n          recompiled.push(line);\r\n          return;\r\n        }\r\n\r\n        // it's quite possible we're in the middle of a multiline\r\n        // comment, so we'll cycle up looking for an opening comment,\r\n        // and if there's one (and not a closing `*/`), then we'll\r\n        // ignore this line as a comment\r\n        if (inMultilineComment(lineNum, lines)) {\r\n          recompiled.push(line);\r\n          return;\r\n        }\r\n\r\n        // now work our way forward to look for '{'\r\n        index = line.indexOf(match) + match.length;\r\n\r\n        if (index === line.length) {\r\n          if (index === line.length && lineNum < (lines.length-1)) {\r\n            // move to the next line\r\n            debug('- moving to next line'); // jshint ignore:line\r\n            recompiled.push(line);\r\n            lineNum++;\r\n            line = lines[lineNum];\r\n            ignore[lineNum] = true;\r\n            index = 0;\r\n          }\r\n\r\n        }\r\n\r\n        while (index < line.length) {\r\n          character = line.substr(index, 1);\r\n          // debug(character, index); // jshint ignore:line\r\n\r\n          if (character === '(') {\r\n            openBrackets++;\r\n          }\r\n\r\n          if (character === ')') {\r\n            openBrackets--;\r\n\r\n            if (openBrackets === 0 && terminator === false) {\r\n              terminator = index;\r\n            }\r\n          }\r\n\r\n          if (character === '{') {\r\n            openBraces++;\r\n          }\r\n\r\n          if (character === '}') {\r\n            openBraces--;\r\n          }\r\n\r\n          if (openBrackets === 0 && (character === ';' || character === '{')) {\r\n            // if we're a non-curlies loop, then convert to curlies to get our code inserted\r\n            // add a close brace after loop to match the open brace before reset\r\n            if (character === ';') {\r\n              if (lineNum !== originalLineNum) {\r\n                debug('- multiline inline loop'); // jshint ignore:line\r\n                // affect the compiled line\r\n                recompiled[originalLineNum] = recompiled[originalLineNum].substring(0, terminator + 1) + '{\\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\\n' + recompiled[originalLineNum].substring(terminator + 1);\r\n                line += '\\n}}\\n';\r\n              } else {\r\n                // simpler\r\n                debug('- single line inline loop'); // jshint ignore:line\r\n                line = line.substring(0, terminator + 1) + '{\\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\\n' + line.substring(terminator + 1) + '\\n}}\\n';\r\n              }\r\n              foundLoopEnd = true;\r\n            } else if (character === '{') {\r\n              debug('- multiline with braces'); // jshint ignore:line\r\n              var insert = ';\\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\\n';\r\n              line = line.substring(0, index + 1) + insert + line.substring(index + 1);\r\n\r\n              index += insert.length;\r\n            }\r\n\r\n            // work out where to put the reset\r\n            if (lineNum === originalLineNum && labelPostion === null) {\r\n              debug('- simple reset insert'); // jshint ignore:line\r\n              line = insertReset(printLineNumber, line, matchPosition);\r\n              index += (';' + method + '({ line: ' + lineNum + ', reset: true }); ').length;\r\n            } else {\r\n              // insert the reset above the originalLineNum OR if this loop used\r\n              // a label, we have to insert the reset *above* the label\r\n              if (labelPostion === null) {\r\n                debug('- reset inserted above original line'); // jshint ignore:line\r\n                recompiled[originalLineNum] = insertReset(printLineNumber, recompiled[originalLineNum], matchPosition);\r\n              } else {\r\n                debug('- reset inserted above matched label on line ' + labelPostion); // jshint ignore:line\r\n                if (recompiled[labelPostion] === undefined) {\r\n                  labelPostion--;\r\n                  matchPosition = 0;\r\n                }\r\n                recompiled[labelPostion] = insertReset(printLineNumber, recompiled[labelPostion], matchPosition);\r\n                labelPostion = null;\r\n              }\r\n            }\r\n\r\n            if (!dofound) {\r\n              if (foundLoopEnd) {\r\n                recompiled.push(line);\r\n                return;\r\n              }\r\n\r\n              debug('searching for closing brace of loop for: ' + line); // jshint ignore:line\r\n              while (line !== null) {\r\n                character = line.substr(index, 1);\r\n\r\n                debug(index, character, openBraces); // jshint ignore:line\r\n\r\n                if (character === '{') {\r\n                  openBraces++;\r\n                }\r\n\r\n                if (character === '}') {\r\n                  openBraces--;\r\n                  if (openBraces === 0) {\r\n                    debug('outside of loop, add a close brace to: ' + line); // jshint ignore:line\r\n                    line = line.substring(0, index+1) + '}' + line.substring(index+1);\r\n                    recompiled.push(line);\r\n                    ignore[lineNum] = true;\r\n                    return;\r\n                  }\r\n                }\r\n\r\n                index++;\r\n\r\n                if (index >= line.length) {\r\n                  recompiled.push(line);\r\n                  ignore[lineNum] = true;\r\n                  lineNum++;\r\n                  line = lines[lineNum];\r\n                  debug(line); // jshint ignore:line\r\n                  index = 0;\r\n                }\r\n              }\r\n              return;\r\n            } else {\r\n              debug('searching for closing `while` statement for: ' + line); // jshint ignore:line\r\n              // cycle forward until we find the close brace, after which should\r\n              // be our while statement to ignore\r\n              findwhile = false;\r\n              while (index < line.length) {\r\n                character = line.substr(index, 1);\r\n\r\n                if (character === '{') {\r\n                  openBraces++;\r\n                }\r\n\r\n                if (character === '}') {\r\n                  openBraces--;\r\n                }\r\n\r\n                if (openBraces === 0) {\r\n                  findwhile = true;\r\n                } else {\r\n                  findwhile = false;\r\n                }\r\n\r\n                if (openBraces === 0) {\r\n                  debug('outside of closure, looking for `while` statement: ' + line); // jshint ignore:line\r\n                }\r\n\r\n                if (findwhile && line.indexOf('while') !== -1) {\r\n                  debug('- exit as we found `while`: ' + line); // jshint ignore:line\r\n                  // TODO: handle while statement in multiple lines\r\n                  line += '}';\r\n                  recompiled.push(line);\r\n                  ignore[lineNum] = true;\r\n                  return;\r\n                }\r\n\r\n                index++;\r\n\r\n                if (index === line.length && lineNum < (lines.length-1)) {\r\n                  recompiled.push(line);\r\n                  ignore[lineNum] = true;\r\n                  lineNum++;\r\n                  line = lines[lineNum];\r\n                  debug(line); // jshint ignore:line\r\n                  index = 0;\r\n                }\r\n              }\r\n              return;\r\n            }\r\n          }\r\n\r\n          index++;\r\n\r\n          if (index === line.length && lineNum < (lines.length-1)) {\r\n            // move to the next line\r\n            debug('- moving to next line'); // jshint ignore:line\r\n            recompiled.push(line);\r\n            lineNum++;\r\n            line = lines[lineNum];\r\n            ignore[lineNum] = true;\r\n            index = 0;\r\n          }\r\n        }\r\n      } else {\r\n        // else we're a regular line, and we shouldn't be touched\r\n        debug('regular line ' + line); // jshint ignore:line\r\n        recompiled.push(line);\r\n      }\r\n    });\r\n\r\n    debug('---- source ----'); // jshint ignore:line\r\n    debug(code); // jshint ignore:line\r\n    debug('---- rewrite ---'); // jshint ignore:line\r\n    debug(recompiled.join('\\n')); // jshint ignore:line\r\n    debug(''); // jshint ignore:line\r\n\r\n    return disableLoopProtection ? code : recompiled.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Injected code in to user's code to **try** to protect against infinite\r\n   * loops cropping up in the code, and killing the browser. Returns true\r\n   * when the loops has been running for more than 100ms.\r\n   */\r\n  loopProtect.protect = function protect(state) {\r\n    loopProtect.counters[state.line] = loopProtect.counters[state.line] || {};\r\n    var line = loopProtect.counters[state.line];\r\n    var now = (new Date()).getTime();\r\n\r\n    if (state.reset) {\r\n      line.time = now;\r\n      line.hit = 0;\r\n      line.last = 0;\r\n    }\r\n\r\n    line.hit++;\r\n    if ((now - line.time) > 100) {//} && line.hit !== line.last+1) {\r\n      // We've spent over 100ms on this loop... smells infinite.\r\n      loopProtect.hit(state.line);\r\n      // Returning true prevents the loop running again\r\n      return true;\r\n    }\r\n    line.last++;\r\n    return false;\r\n  };\r\n\r\n  loopProtect.hit = function hit(line) {\r\n    var msg = 'Exiting potential infinite loop at line ' + line + '. To disable loop protection: add \"// noprotect\" to your code';\r\n    console.error(msg);\r\n  };\r\n\r\n  loopProtect.reset = function reset() {\r\n    // reset the counters\r\n    loopProtect.counters = {};\r\n  };\r\n\r\n  return loopProtect;\r\n\r\n});\r\n\ndefine('skylark-loopprotect', ['skylark-loopprotect/main'], function (main) { return main; });\n\n"]}