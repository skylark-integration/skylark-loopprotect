{"version":3,"sources":["main.js"],"names":["define","debug","re","reSingle","labelRe","comments","loopProtect","code","offset","recompiled","lines","split","disableLoopProtection","method","alias","ignore","pushonly","labelPostion","insertReset","lineNum","line","matchPosition","slice","forEach","lastIndex","toLowerCase","indexOf","index","originalLineNum","printLineNumber","character","dofound","findwhile","terminator","matches","match","length","labelMatch","openBrackets","openBraces","foundLoopEnd","DEBUG","inCommentOrString","inMultilineComment","beforeLoop","theRest","join","substr","replace","capture","i","target","trim","directlyBeforeLoop","push","substring","insert","undefined","j","closeCommentTags","closePos","openPos","counters","state","console","log","apply","arguments","protect","now","Date","getTime","reset","time","hit","last","msg","error"],"mappings":"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","file":"../main.js","sourcesContent":["define([],function(){\r\n  /*global DEBUG*/\r\n  'use strict';\r\n  var debug = null;\r\n\r\n  // the standard loops - note that recursive is not supported\r\n  var re = /\\b(for|while|do)\\b/g;\r\n  var reSingle = /\\b(for|while|do)\\b/;\r\n  var labelRe = /\\b(?!default:)([a-z_]{1}\\w+:)/i;\r\n  var comments = /(?:\\/\\*(?:[\\s\\S]*?)\\*\\/)|(?:([\\s;])+\\/\\/(?:.*)$)/gm;\r\n\r\n  var loopProtect = rewriteLoops;\r\n\r\n  // used in the loop detection\r\n  loopProtect.counters = {};\r\n\r\n  // expose debug info\r\n  loopProtect.debug = function debugSwitch(state) {\r\n    debug = state ? function () {\r\n      console.log.apply(console, [].slice.apply(arguments));\r\n    } : function () {};\r\n  };\r\n\r\n  loopProtect.debug(false); // off by default\r\n\r\n  // the method - as this could be aliased to something else\r\n  loopProtect.alias = 'loopProtect';\r\n\r\n  function inMultilineComment(lineNum, lines) {\r\n    if (lineNum === 0) {\r\n      return false;\r\n    }\r\n\r\n    var j = lineNum;\r\n    var closeCommentTags = 1; // let's assume we're inside a comment\r\n    var closePos = -1;\r\n    var openPos = -1;\r\n\r\n    do {\r\n      DEBUG && debug('looking backwards ' + lines[j]); // jshint ignore:line\r\n      closePos = lines[j].indexOf('*/');\r\n      openPos = lines[j].indexOf('/*');\r\n\r\n      if (closePos !== -1) {\r\n        closeCommentTags++;\r\n      }\r\n\r\n      //check for single line /* comment */ formatted comments.\r\n      if (closePos === lines[j].length - 2 && openPos !== -1) {\r\n        closeCommentTags--;\r\n      }\r\n\r\n      if (openPos !== -1) {\r\n        closeCommentTags--;\r\n\r\n        if (closeCommentTags === 0) {\r\n          DEBUG && debug('- exit: part of a multiline comment'); // jshint ignore:line\r\n          return true;\r\n        }\r\n      }\r\n      j -= 1;\r\n    } while (j !== 0);\r\n\r\n    return false;\r\n  }\r\n\r\n  function inCommentOrString(index, line) {\r\n    var character;\r\n    while (--index > -1) {\r\n      character = line.substr(index, 1);\r\n      if (character === '\"' || character === '\\'' || character === '.') {\r\n        // our loop keyword was actually either in a string or a property, so let's exit and ignore this line\r\n        DEBUG && debug('- exit: matched inside a string or property key'); // jshint ignore:line\r\n        return true;\r\n      }\r\n      if (character === '/' || character === '*') {\r\n        // looks like a comment, go back one to confirm or not\r\n        --index;\r\n        if (character === '/') {\r\n          // we've found a comment, so let's exit and ignore this line\r\n          DEBUG && debug('- exit: part of a comment'); // jshint ignore:line\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function directlyBeforeLoop(index, lineNum, lines) {\r\n    reSingle.lastIndex = 0;\r\n    labelRe.lastIndex = 0;\r\n    var beforeLoop = false;\r\n\r\n    var theRest = lines.slice(lineNum).join('\\n').substr(index).replace(labelRe, '');\r\n    theRest.replace(reSingle, function commentStripper(match, capture, i) {\r\n      var target = theRest.substr(0, i).replace(comments, '').trim();\r\n      DEBUG && debug('- directlyBeforeLoop: ' + target); // jshint ignore:line\r\n      if (target.length === 0) {\r\n        beforeLoop = true;\r\n      }\r\n      // strip comments out of the target, and if there's nothing else\r\n      // it's a valid label...I hope!\r\n    });\r\n\r\n    return beforeLoop;\r\n  }\r\n\r\n  /**\r\n   * Look for for, while and do loops, and inserts *just* at the start of the\r\n   * loop, a check function.\r\n   */\r\n  function rewriteLoops(code, offset) {\r\n    var recompiled = [];\r\n    var lines = code.split('\\n');\r\n    var disableLoopProtection = false;\r\n    var method = loopProtect.alias + '.protect';\r\n    var ignore = {};\r\n    var pushonly = {};\r\n    var labelPostion = null;\r\n\r\n    function insertReset(lineNum, line, matchPosition) {\r\n      // recompile the line with the reset **just** before the actual loop\r\n      // so that we insert in to the correct location (instead of possibly\r\n      // outside the logic\r\n      // wrap reset and loop in a block to avoid one line loop behind\r\n      // `if (false)`, insert the open brace in this function, and the close\r\n      // brace after loop close brace.\r\n      return line.slice(0, matchPosition) + '{;' + method + '({ line: ' + lineNum + ', reset: true }); ' + line.slice(matchPosition);\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    lines.forEach(function eachLine(line, lineNum) {\r\n      // reset our regexp each time.\r\n      re.lastIndex = 0;\r\n      labelRe.lastIndex = 0;\r\n\r\n      if (disableLoopProtection) {\r\n        return;\r\n      }\r\n\r\n      if (line.toLowerCase().indexOf('noprotect') !== -1) {\r\n        disableLoopProtection = true;\r\n      }\r\n\r\n      var index = -1;\r\n      var matchPosition = -1;\r\n      var originalLineNum = lineNum;\r\n      // +1 since we're humans and don't read lines numbers from zero\r\n      var printLineNumber = lineNum - offset + 1;\r\n      var character = '';\r\n      // special case for `do` loops, as they're end with `while`\r\n      var dofound = false;\r\n      var findwhile = false;\r\n      var terminator = false;\r\n      var matches = line.match(re) || [];\r\n      var match = matches.length ? matches[0] : '';\r\n      var labelMatch = line.match(labelRe) || [];\r\n      var openBrackets = 0;\r\n      var openBraces = 0;\r\n      var foundLoopEnd = false;\r\n\r\n      if (labelMatch.length) {\r\n        DEBUG && debug('- label match'); // jshint ignore:line\r\n        index = line.indexOf(labelMatch[1]);\r\n        if (!inCommentOrString(index, line)) {\r\n          if (!inMultilineComment(lineNum, lines)) {\r\n            if (directlyBeforeLoop(index, lineNum, lines)) {\r\n              DEBUG && debug('- found a label: \"' + labelMatch[0] + '\"'); // jshint ignore:line\r\n              labelPostion = lineNum;\r\n            } else {\r\n              DEBUG && debug('- ignored \"label\", false positive'); // jshint ignore:line\r\n            }\r\n          } else {\r\n            DEBUG && debug('- ignored label in multline comment'); // jshint ignore:line\r\n          }\r\n        } else {\r\n          DEBUG && debug('- ignored label in string or comment'); // jshint ignore:line\r\n        }\r\n      }\r\n\r\n      if (ignore[lineNum]) {\r\n        DEBUG && debug(' -exit: ignoring line ' + lineNum +': ' + line); // jshint ignore:line\r\n        return;\r\n      }\r\n\r\n      if (pushonly[lineNum]) {\r\n        DEBUG && debug('- exit: ignoring, but adding line ' + lineNum + ': ' + line); // jshint ignore:line\r\n        recompiled.push(line);\r\n        return;\r\n      }\r\n\r\n      // if there's more than one match, we just ignore this kind of loop\r\n      // otherwise I'm going to be writing a full JavaScript lexer...and god\r\n      // knows I've got better things to be doing.\r\n      if (match && matches.length === 1 && line.indexOf('jsbin') === -1) {\r\n        DEBUG && debug('match on ' + match + '\\n'); // jshint ignore:line\r\n\r\n        // there's a special case for protecting `do` loops, we need to first\r\n        // prtect the `do`, but then ignore the closing `while` statement, so\r\n        // we reset the search state for this special case.\r\n        dofound = match === 'do';\r\n\r\n        // make sure this is an actual loop command by searching backwards\r\n        // to ensure it's not a string, comment or object property\r\n        matchPosition = index = line.indexOf(match);\r\n\r\n        // first we need to walk backwards to ensure that our match isn't part\r\n        // of a string or part of a comment\r\n        if (inCommentOrString(index, line)) {\r\n          recompiled.push(line);\r\n          return;\r\n        }\r\n\r\n        // it's quite possible we're in the middle of a multiline\r\n        // comment, so we'll cycle up looking for an opening comment,\r\n        // and if there's one (and not a closing `*/`), then we'll\r\n        // ignore this line as a comment\r\n        if (inMultilineComment(lineNum, lines)) {\r\n          recompiled.push(line);\r\n          return;\r\n        }\r\n\r\n        // now work our way forward to look for '{'\r\n        index = line.indexOf(match) + match.length;\r\n\r\n        if (index === line.length) {\r\n          if (index === line.length && lineNum < (lines.length-1)) {\r\n            // move to the next line\r\n            DEBUG && debug('- moving to next line'); // jshint ignore:line\r\n            recompiled.push(line);\r\n            lineNum++;\r\n            line = lines[lineNum];\r\n            ignore[lineNum] = true;\r\n            index = 0;\r\n          }\r\n\r\n        }\r\n\r\n        while (index < line.length) {\r\n          character = line.substr(index, 1);\r\n          // DEBUG && debug(character, index); // jshint ignore:line\r\n\r\n          if (character === '(') {\r\n            openBrackets++;\r\n          }\r\n\r\n          if (character === ')') {\r\n            openBrackets--;\r\n\r\n            if (openBrackets === 0 && terminator === false) {\r\n              terminator = index;\r\n            }\r\n          }\r\n\r\n          if (character === '{') {\r\n            openBraces++;\r\n          }\r\n\r\n          if (character === '}') {\r\n            openBraces--;\r\n          }\r\n\r\n          if (openBrackets === 0 && (character === ';' || character === '{')) {\r\n            // if we're a non-curlies loop, then convert to curlies to get our code inserted\r\n            // add a close brace after loop to match the open brace before reset\r\n            if (character === ';') {\r\n              if (lineNum !== originalLineNum) {\r\n                DEBUG && debug('- multiline inline loop'); // jshint ignore:line\r\n                // affect the compiled line\r\n                recompiled[originalLineNum] = recompiled[originalLineNum].substring(0, terminator + 1) + '{\\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\\n' + recompiled[originalLineNum].substring(terminator + 1);\r\n                line += '\\n}}\\n';\r\n              } else {\r\n                // simpler\r\n                DEBUG && debug('- single line inline loop'); // jshint ignore:line\r\n                line = line.substring(0, terminator + 1) + '{\\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\\n' + line.substring(terminator + 1) + '\\n}}\\n';\r\n              }\r\n              foundLoopEnd = true;\r\n            } else if (character === '{') {\r\n              DEBUG && debug('- multiline with braces'); // jshint ignore:line\r\n              var insert = ';\\nif (' + method + '({ line: ' + printLineNumber + ' })) break;\\n';\r\n              line = line.substring(0, index + 1) + insert + line.substring(index + 1);\r\n\r\n              index += insert.length;\r\n            }\r\n\r\n            // work out where to put the reset\r\n            if (lineNum === originalLineNum && labelPostion === null) {\r\n              DEBUG && debug('- simple reset insert'); // jshint ignore:line\r\n              line = insertReset(printLineNumber, line, matchPosition);\r\n              index += (';' + method + '({ line: ' + lineNum + ', reset: true }); ').length;\r\n            } else {\r\n              // insert the reset above the originalLineNum OR if this loop used\r\n              // a label, we have to insert the reset *above* the label\r\n              if (labelPostion === null) {\r\n                DEBUG && debug('- reset inserted above original line'); // jshint ignore:line\r\n                recompiled[originalLineNum] = insertReset(printLineNumber, recompiled[originalLineNum], matchPosition);\r\n              } else {\r\n                DEBUG && debug('- reset inserted above matched label on line ' + labelPostion); // jshint ignore:line\r\n                if (recompiled[labelPostion] === undefined) {\r\n                  labelPostion--;\r\n                  matchPosition = 0;\r\n                }\r\n                recompiled[labelPostion] = insertReset(printLineNumber, recompiled[labelPostion], matchPosition);\r\n                labelPostion = null;\r\n              }\r\n            }\r\n\r\n            if (!dofound) {\r\n              if (foundLoopEnd) {\r\n                recompiled.push(line);\r\n                return;\r\n              }\r\n\r\n              DEBUG && debug('searching for closing brace of loop for: ' + line); // jshint ignore:line\r\n              while (line !== null) {\r\n                character = line.substr(index, 1);\r\n\r\n                DEBUG && debug(index, character, openBraces); // jshint ignore:line\r\n\r\n                if (character === '{') {\r\n                  openBraces++;\r\n                }\r\n\r\n                if (character === '}') {\r\n                  openBraces--;\r\n                  if (openBraces === 0) {\r\n                    DEBUG && debug('outside of loop, add a close brace to: ' + line); // jshint ignore:line\r\n                    line = line.substring(0, index+1) + '}' + line.substring(index+1);\r\n                    recompiled.push(line);\r\n                    ignore[lineNum] = true;\r\n                    return;\r\n                  }\r\n                }\r\n\r\n                index++;\r\n\r\n                if (index >= line.length) {\r\n                  recompiled.push(line);\r\n                  ignore[lineNum] = true;\r\n                  lineNum++;\r\n                  line = lines[lineNum];\r\n                  DEBUG && debug(line); // jshint ignore:line\r\n                  index = 0;\r\n                }\r\n              }\r\n              return;\r\n            } else {\r\n              DEBUG && debug('searching for closing `while` statement for: ' + line); // jshint ignore:line\r\n              // cycle forward until we find the close brace, after which should\r\n              // be our while statement to ignore\r\n              findwhile = false;\r\n              while (index < line.length) {\r\n                character = line.substr(index, 1);\r\n\r\n                if (character === '{') {\r\n                  openBraces++;\r\n                }\r\n\r\n                if (character === '}') {\r\n                  openBraces--;\r\n                }\r\n\r\n                if (openBraces === 0) {\r\n                  findwhile = true;\r\n                } else {\r\n                  findwhile = false;\r\n                }\r\n\r\n                if (openBraces === 0) {\r\n                  DEBUG && debug('outside of closure, looking for `while` statement: ' + line); // jshint ignore:line\r\n                }\r\n\r\n                if (findwhile && line.indexOf('while') !== -1) {\r\n                  DEBUG && debug('- exit as we found `while`: ' + line); // jshint ignore:line\r\n                  // TODO: handle while statement in multiple lines\r\n                  line += '}';\r\n                  recompiled.push(line);\r\n                  ignore[lineNum] = true;\r\n                  return;\r\n                }\r\n\r\n                index++;\r\n\r\n                if (index === line.length && lineNum < (lines.length-1)) {\r\n                  recompiled.push(line);\r\n                  ignore[lineNum] = true;\r\n                  lineNum++;\r\n                  line = lines[lineNum];\r\n                  DEBUG && debug(line); // jshint ignore:line\r\n                  index = 0;\r\n                }\r\n              }\r\n              return;\r\n            }\r\n          }\r\n\r\n          index++;\r\n\r\n          if (index === line.length && lineNum < (lines.length-1)) {\r\n            // move to the next line\r\n            DEBUG && debug('- moving to next line'); // jshint ignore:line\r\n            recompiled.push(line);\r\n            lineNum++;\r\n            line = lines[lineNum];\r\n            ignore[lineNum] = true;\r\n            index = 0;\r\n          }\r\n        }\r\n      } else {\r\n        // else we're a regular line, and we shouldn't be touched\r\n        DEBUG && debug('regular line ' + line); // jshint ignore:line\r\n        recompiled.push(line);\r\n      }\r\n    });\r\n\r\n    DEBUG && debug('---- source ----'); // jshint ignore:line\r\n    DEBUG && debug(code); // jshint ignore:line\r\n    DEBUG && debug('---- rewrite ---'); // jshint ignore:line\r\n    DEBUG && debug(recompiled.join('\\n')); // jshint ignore:line\r\n    DEBUG && debug(''); // jshint ignore:line\r\n\r\n    return disableLoopProtection ? code : recompiled.join('\\n');\r\n  }\r\n\r\n  /**\r\n   * Injected code in to user's code to **try** to protect against infinite\r\n   * loops cropping up in the code, and killing the browser. Returns true\r\n   * when the loops has been running for more than 100ms.\r\n   */\r\n  loopProtect.protect = function protect(state) {\r\n    loopProtect.counters[state.line] = loopProtect.counters[state.line] || {};\r\n    var line = loopProtect.counters[state.line];\r\n    var now = (new Date()).getTime();\r\n\r\n    if (state.reset) {\r\n      line.time = now;\r\n      line.hit = 0;\r\n      line.last = 0;\r\n    }\r\n\r\n    line.hit++;\r\n    if ((now - line.time) > 100) {//} && line.hit !== line.last+1) {\r\n      // We've spent over 100ms on this loop... smells infinite.\r\n      loopProtect.hit(state.line);\r\n      // Returning true prevents the loop running again\r\n      return true;\r\n    }\r\n    line.last++;\r\n    return false;\r\n  };\r\n\r\n  loopProtect.hit = function hit(line) {\r\n    var msg = 'Exiting potential infinite loop at line ' + line + '. To disable loop protection: add \"// noprotect\" to your code';\r\n    console.error(msg);\r\n  };\r\n\r\n  loopProtect.reset = function reset() {\r\n    // reset the counters\r\n    loopProtect.counters = {};\r\n  };\r\n\r\n  return loopProtect;\r\n\r\n});\r\n"]}